<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="keywords" content="Aoki,Atsushi,Smalltalk,Smalltalker,Program,Programmer,Object,Oriented,Programming">
<meta name="description" content="ソフトウェア工学IIのホームページ">
<meta name="author" content="AOKI Atsushi">
<link rev="made" href="index.html">
<link rel="index" href="index.html">
<style type="text/css">
<!--
body {
  background-color : #ffffff;
  margin : 20px;
  padding : 10px;
  font-family : serif;
  font-size : 10pt;
}
a {
  text-decoration : underline;
  color : #000000;
}
a:link {
  background-color : #ffddbb;
}
a:visited {
  background-color : #ccffcc;
}
a:hover {
  background-color : #dddddd;
}
a:active {
  background-color : #dddddd;
}
div.belt {
  background-color : #eeeeee;
  padding : 0px 4px;
}
div.belt-yellow {
  background-color : #ffffcc;
  padding : 0px 4px;
}
div.belt-blue {
  background-color : #ddeeff;
  padding : 0px 4px;
}
div.right-small {
  text-align : right;
  font-size : 8pt;
}
img.border {
  border-width : 1px;
  border-color : #000000;
  vertical-align : middle;
}
img.borderless {
  border-width : 0px;
  vertical-align : middle;
}
p.belt {
  background-color : #ffeedd;
  padding : 4px 8px;
}
p.belt-blue {
  background-color : #ddeeff;
  padding : 4px 8px;
}
pre.belt {
  background-color : #ddeeff;
  padding : 4px 8px;
}
pre.belt-yellow {
  background-color : #ffffcc;
  padding : 4px 8px;
}
table {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  font-family : serif;
  font-size : 10pt;
}
table.profile {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  font-family : serif;
  font-size : 10pt;
  margin-top : 8px;
  margin-left : 8px;
  margin-right : 8px;
  margin-bottom : 8px;
}
table.belt {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  background-color : #ffeedd;
  padding : 0px 0px;
  width : 100%;
}
table.content {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 2px 4px;
}
table.font-fixed {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 2px 4px;
  font-family : monospace;
}
table.nest {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 0px 0px;
}
td {
  padding : 0px 0px;
  vertical-align : middle;
}
td.center {
  text-align : center;
}
td.center-half {
  text-align : center;
  width : 50%;
  font-size : 8pt;
}
td.center-small {
  text-align : center;
  font-size : 8pt;
  padding : 0px 4px;
}
td.center-small-nopadding {
  text-align : center;
  font-size : 8pt;
  padding : 0px 0px;
}
td.center-white {
  text-align : center;
  background-color : #ffffff;
}
td.center-small-white {
  text-align : center;
  font-size : 8pt;
  background-color : #ffffff;
}
td.center-border1 {
  text-align : center;
  vertical-align : middle;
  empty-cells : show;
  border-style : solid;
  border-width : 1px;
  border-color : #ffc080;
  width : 22px;
  height : 22px;
}
td.left-small {
  text-align : left;
  font-size : 8pt;
  padding : 0px 4px;
}
td.left-small-white {
  text-align : left;
  font-size : 8pt;
  padding : 0px 4px;
  background-color : #ffffff;
}
td.right-small {
  text-align : right;
  font-size : 8pt;
  padding : 0px 4px;
}
td.right-small-white {
  text-align : right;
  font-size : 8pt;
  padding : 0px 4px;
  background-color : #ffffff;
}
th {
  padding : 0px 0px;
  vertical-align : middle;
}
#menu {
  margin: 0px 0px 0px 0px;
  padding: 0px;
  height: 32px;
}
#menu ul {
  margin: 0px;
  padding: 0px;
  list-style: none;
  text-align: center;
  clear: both;
}
#menu li {
  margin: 0px 5px 0px 0px;
  padding: 0px;
  float: left;
}
#menu a {
  display: block;
  padding: 2px 4px;
  text-decoration: none;
  margin: 0px;
  font-weight: bold;
  background: #FFFFFF;
  color: #333333;
  border: 1px solid #666666;
}
#menu a:hover {
  display: block;
  padding: 2px 4px;
  border-bottom: 1px solid #000000;
  text-decoration: none;
  background: #FFCC66;
}
#menu .current {
  background-color: #F45F57;
  font-weight: bold;
  color: #FFFFFF;
  border: 1px solid #333333;
}
-->
</style>
<title>ソフトウェア工学II「樹状整列」プログラム</title>
</head>
<body>
<div id="menu">
<ul>
  <li><a href="../index.html">ホーム</a></li>
  <li><a href="../Requirement/index.html">要求仕様書</a></li>
  <li><a href="../DevelopmentPlan/index.html">開発計画書</a></li>
  <li><a href="../BasicDesign/index.html">基本設計書</a></li>
  <li><a href="../DetailDesign/index.html">詳細設計書</a></li>
  <li><a href="../TestSpecification/index.html">テスト仕様書</a></li>
  <li><a href="../TestResult/index.html">テスト結果</a></li>
  <li><a href="../DevelopmentResult/index.html">開発実績</a></li>
  <li><a href="../Program/index.html" class="current">プログラム</a></li>
  <li><a href="../Manual/index.html">マニュアル</a></li>
</ul>
</div>
<hr>
<h2>ソフトウェア工学II「樹状整列」プログラム</h2>
<div class="belt">
<h3><a name="KanseiSaseteKudasai">プログラムのソースコード</a></h3>
</div>
<div >
    <h3><pre class = "belt-yellow">Branch</pre></h3>
</div>
<pre>
package forest;

import java.awt.Graphics;

/**
 * 樹状整列におけるブランチ（枝）を担うクラスになります。
 */
public class Branch extends Object {

	/**
	 * ブランチ（枝）の始点となるノードを記憶するフィールドです。
	 * 良好（2019/7/29）
	 */
	private Node start;

	/**
	 * ブランチ（枝）の終点となるノードを記憶するフィールドです。
	 * 良好（2019/7/29）
	 */
	private Node end;

	/**
	 * インスタンスを生成する。
	 * @param from 元のノード(親)
	 * @param to 新たなノード(子)
	 * 良好（2019/7/29）
	 */
	public Branch(Node from, Node to) {
		this.start = from;
		this.end = to;
		return;
	}

	/**
	 * 描写メソッド
	 * @param aGraphics 描画引数
	 * 良好（2019/7/29）
	 */
	public void draw(Graphics aGraphics) {
		Integer startX = this.start.getBounds().x + this.start.getBounds().width;
		Integer startY = this.start.getBounds().y + (this.start.getBounds().height / 2);
		Integer endX = this.end.getBounds().x;
		Integer endY = this.end.getBounds().y + (this.end.getExtent().y / 2);
		aGraphics.drawLine(startX, startY, endX, endY);
		return;
	}

	/**
	 * 元ノードを応答
	 * @return 元ノード
	 * 良好（2019/7/29）
	 */
	public Node start() {
		return this.start;
	}

	/**
	 * 新たなノード
	 * @return 新たなノード
	 * 良好（2019/7/29）
	 */
	public Node end() {
		return this.end;
	}

	/**
	 * 自分自身を文字列に変換するメソッドです。
	 * @return 自分自身を表す文字列
	 * 良好（2019/7/29）
	 */
	public String toString() {
		StringBuffer aBuffer = new StringBuffer();
		Class<?> aClass = this.getClass();
		aBuffer.append(aClass.getName());
		aBuffer.append(" [親ノード：");
		aBuffer.append(this.start.getName());
		aBuffer.append(", 子ノード：");
		aBuffer.append(this.end.getName());
		aBuffer.append("]");
		return aBuffer.toString();
	}

}
</pre>
<div >
    <h3><pre class = "belt-yellow">TreeModel</pre></h3>
</div>
<pre>
package forest;

import java.io.File;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Objects;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.HashMap;
import java.awt.Point;
import mvc.Model;

/**
* 樹状整列におけるMVCのモデル（M）を担うクラスになります。
*/

public class TreeModel extends Model {

	/**
	* 樹状整列それ自身を記憶しておくフィールドです。
	* 良好 (7月29日)
	*/
	private Forest forest;

	/**
	* 依存物 TreeViewのインスタンスたちを束縛する。
	* 良好　(7月29日)
	*/
	protected ArrayList<TreeView> dependents;


	/**
	* このクラスのインスタンスを生成するコンストラクタです。
	* @param  aFile 樹状整列データファイル
	* 良好　(7月29日)
	*/
	public TreeModel(File aFile)
	{
		super();
		this.dependents = new ArrayList<TreeView>();
		this.forest = new Forest();
		this.read(aFile);
		return;
	}


	/**
	* 指定されたビューを依存物に設定する
	* @param aView このモデルの依存物となるビュー
	* 良好　(7月29日)
	*/
	public void addDependent(TreeView aView)
	{
		dependents.add(aView);
		return;
	}


	/**
	* アニメーションを行うメソッドです。
	* 良好 (7月29日)
	*/
	public void animate()
	{
		this.arrange();
		// System.out.println(this.forest.toString());
		return;
	}

	/**
	* 初期化する。
	* 良好 (7月29日)
	*/
	private void initialize()
	{
		dependents = new ArrayList<TreeView>();
		forest = null;
		return;
	}

	/**
	* 樹状整列を行うメソッドです。
	* 良好　(7月29日)
	*/
	public void arrange()
	{
		this.forest.arrange(this);
		return;
	}

	/**
	* モデルの内部状態が変化していたので、自分の依存物へupdateのメッセージを送信する。
	* 良好　(7月29日)
	*/
	public void changed()
	{
		dependents.forEach((TreeView aView) -> { aView.paintComponent(aView.getGraphics());});
		return;
	}

	/**
	* 樹状整列をそれ自身を応答するメソッドです。
	* @return 樹状整列それ自身
	* 良好　(7月29日)
	*/
	public Forest forest()
	{
		return this.forest;
	}

	/**
	* 樹状整列をそれ自身を応答するメソッドです。
	* @param aFile
	* 修正　(7月29日)
	* 良好　(7月29日)
	*/
	protected void read(File aFile)
	{
		try
		{
			Boolean treesDataFlag = false;
			Boolean nodesDataFlag = false;
			Boolean branchesDataFlag = false;
			Boolean isNumberFlag = true;
			StringBuffer aBuffer = new StringBuffer();
			BufferedReader in = new BufferedReader(new FileReader(aFile));
			HashMap<String, Node> nodeMap = new HashMap<>();
			String line;

			while((line = in.readLine()) != null)
			{
				String[] data = line.split(", ");

				if(Objects.equals(line, Constants.TagOfTrees))
				{
					treesDataFlag = true;
					nodesDataFlag = false;
					branchesDataFlag = false;
				}else if(Objects.equals(line, Constants.TagOfNodes))
				{
					treesDataFlag = false;
					nodesDataFlag = true;
					branchesDataFlag = false;
				}else if(Objects.equals(line, Constants.TagOfBranches))
				{
					treesDataFlag = false;
					nodesDataFlag = false;
					branchesDataFlag = true;
				}else
				{
					if(treesDataFlag)
					{
						aBuffer.append(data[0]);
						aBuffer.append(System.getProperty("line.separator"));
					}
					if(nodesDataFlag)
					{
						try
						{
			                Integer.parseInt(data[0]);
			            }
			            catch (NumberFormatException e)
			            {
			            	e.printStackTrace();
			                isNumberFlag = false;
			            }
						if(isNumberFlag && data.length > 1)
						{
							Node aNode = new Node(data[1]);
							aNode.setLocation(new Point(0, Integer.valueOf(data[0])*Constants.DefaultFont.getSize()));
							aNode.setStatus(Constants.UnVisited);
							nodeMap.put(data[0], aNode);
							this.forest.addNode(aNode);
						}

					}
					if(branchesDataFlag)
					{
						try
						{
			                Integer.parseInt(data[0]);
			                if(data.length > 1) Integer.parseInt(data[1]);
			            } catch (NumberFormatException e)
			            {
			            	e.printStackTrace();
			                isNumberFlag = false;
			            }
			            if(isNumberFlag && data.length > 1)
			            {
			            	if(nodeMap.get(data[0]) != null && nodeMap.get(data[1]) != null) this.forest.addBranch(new Branch(nodeMap.get(data[0]), nodeMap.get(data[1])));
			            }
					}
				}
				isNumberFlag = true;
			}
			this.forest.setForm(aBuffer.toString());
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return;
	}

	/**
	* 樹状整列の根源(ルート)になるノードを探し出して応答するメソッドです。
	* @return
	* 良好　(7月29日)
	*/
	public Node root()
	{
		return this.forest.rootNodes().get(0);
	}

	/**
	* 樹状整列の根源(ルート)になるノードたちを探し出して応答するメソッドです。
	* @return
	* 良好　(7月29日)
	*/
	public ArrayList<Node> roots() {
		return this.forest.rootNodes();
	}

}
</pre>
<div >
    <h3><pre class = "belt-yellow">TreeView</pre></h3>
</div>
<pre>
package forest;

import java.awt.Graphics;
import java.awt.Point;
import mvc.View;

/**
 * 樹状整列におけるMVCのビュー（V）を担うクラスになります。
 */
@SuppressWarnings("serial")
public class TreeView extends View
{

	/**
	 * 情報を握っているTreeModelのインスタンスを束縛する。
	 * 良好 (7月29日)
	 */
	protected TreeModel model;

	/**
	 * 制御を司るTreeControllerのインスタンスを束縛する。
	 * 良好 (7月29日)
	 */
	protected TreeController controller;

	/**
	 * このクラスのインスタンスを生成するコンストラクタです。
	 * @param  aModel モデル（Modelのインスタンス）
	 * 良好 (7月29日)
	 */
	public TreeView(TreeModel aModel)
	{
		super(aModel);
		model = aModel;
		model.addDependent(this);
		controller = new TreeController();
		controller.setModel(model);
		controller.setView(this);
		return;
	}

	/**
	 * このパネル（ビュー）の描画が必要になったときに動作するメソッドです。
	 * @param aGraphics グラフィクス（描画コンテクスト）
	 * 良好 (7月29日)
	 */
	public void paintComponent(Graphics aGraphics)
	{
		this.update();
		this.model.forest().draw(aGraphics);
		return;
	}

	/**
	 * スクロール量を指定された座標分だけ相対スクロールする。
	 * @param aPoint X軸とY軸のスクロール量を表す座標
	 * 良好 (7月29日)
	 */
	public void scrollBy2(Point aPoint)
	{

		int x = aPoint.x;
		int y = aPoint.y;
		model.forest().moveBounds(new Point(x, y));
		this.model.forest().arrange();
		return;
	}

	/**
	 * 指定された位置（座標）にノードが存在するかを調べるメソッドです。
	 * @param  aPoint 位置（ビュー座標）
	 * @return ノード、もしも見つからなかった場合には、nullを応答します。
	 * 良好 (7月29日)
	 */
	public Node whichOfNodes(Point aPoint)
	{
		return model.forest().whichOfNodes(aPoint);
	}

}
</pre>
<div >
    <h3><pre class = "belt-yellow">TreeController</pre></h3>
</div>
<pre>
package forest;

import java.awt.event.MouseEvent;
import mvc.Controller;
import java.awt.Point;
import java.awt.Cursor;
import java.awt.Component;
import java.util.ArrayList;
import java.util.Objects;

/**
 * 樹状整列におけるMVCのコントローラ（C）を担うクラスになります。
 */
public class TreeController extends Controller
{

	/**
	 * 情報を握っているTreeModelのインスタンスを束縛する。
	 * 良好　(7月29日)
	 */
	protected TreeModel model;

	/**
	 * 表示を司るTreeViewのインスタンスを束縛する。
	 * 良好 (7月29日)
	 */
	protected TreeView view;

	/**
	 * 以前にマウスのボタンが押下された場所をPointのインスタンスとして束縛する。
	 * 良好 (7月29日)
	 */
	private Point changePlace;

	/**
	 * 現在にマウスのボタンが押下された場所をPointのインスタンスとして束縛する。
	 * 良好 (7月29日)
	 */
	private Point now;

	/**
	 * インスタンスを生成して応答する。
	 * すべてのインスタンス変数（model, view, changePlace, now）をnull化する。
	 * 良好(7月29日)
	 */
	public TreeController()
	{
		super();
		model = null;
		view = null;
		changePlace = null;
		now = null;
		return;
	}

	/**
	 * 指定されたモデルをインスタンス変数modelに設定する。
	 * @param aModel このコントローラのモデル
	 * 良好 (7月29日)
	 */
	public void setModel(TreeModel aModel)
	{
		model = aModel;
		return;
	}

	/**
	 * マウスカーサの形状を移動の形に変化させ、指定されたマウスイベントからマウスカーサの位置を獲得して、
	 * インスタンス変数changePlaceに設定すると共に、以前のマウスカーサの位置からの差分を計算する。
	 * そして、その差分だけビューに対してスクロールを依頼し、その後にビューの再描画を依頼する。
	 * 最後にインスタンス変数nowをインスタンス変数changePlaceに更新する。
	 * @param aMouseEvent マウスイベント
	 * 良好　(7月29日)
	 */
	public void mouseDragged(MouseEvent aMouseEvent)
	{
		ArrayList<Node> rootNodes = this.model.roots();
		for(Node aNode : rootNodes)
		{
			if(!(Objects.equals(aNode.getStatus(), Constants.Visited))) return;
		}
		Cursor aCursor = Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);
		Component aComponent = (Component)aMouseEvent.getSource();
		aComponent.setCursor(aCursor);
		now = aMouseEvent.getPoint();
		int x = now.x - changePlace.x;
		int y = now.y - changePlace.y;
		Point point = new Point(x, y);
		view.scrollBy2(point);
		view.update();
		changePlace = now;
		return;
	}

	/**
	 * 指定されたビューをインスタンス変数viewに設定し、
	 * ビューのマウスのリスナおよびモーションリスナそしてホイールリスナをこのコントローラにする。
	 * @param aView このコントローラのビュー
	 * 良好　(7月29日)
	 */
	public void setView(TreeView aView)
	{
		view = aView;
		view.addMouseListener(this);
		view.addMouseMotionListener(this);
		view.addMouseWheelListener(this);
		return;
	}

	/**
	 * マウスカーサの形状を十字に変化させ、指定されたマウスイベントからマウスカーサの位置を獲得して、
	 * インスタンス変数nowに設定する共にインスタンス変数changePlaceをインスタンス変数nowに更新する。
	 * @param aMouseEvent マウスイベント
	 * 良好　(7月29日)
	 */
	public void mousePressed(MouseEvent aMouseEvent)
	{
		Cursor aCursor = Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR);
		Component aComponent = (Component)aMouseEvent.getSource();
		aComponent.setCursor(aCursor);
		now = aMouseEvent.getPoint();
		changePlace = now;
		return;
	}

	/**
	 * マウスクリック判定を行うメソッド
	 * @param aMouseEvent マウスのクリック情報
	 * 良好 (7月29日)
	 */
	public void mouseClicked(MouseEvent aMouseEvent)
	{
		Point aPoint = aMouseEvent.getPoint();
		Node aNode = view.whichOfNodes(aPoint);
		if(aNode != null)
		{
			System.out.printf("%s%n", aNode.getName());
		}
		return;
	}
}
</pre>
<hr>
<div class="right-small">Copyright 20xx Project xx, Updated: 2019/07/29 (Created: 2009/11/11)</div>
</body>
</html>
