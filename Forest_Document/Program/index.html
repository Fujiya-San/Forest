<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="keywords" content="Aoki,Atsushi,Smalltalk,Smalltalker,Program,Programmer,Object,Oriented,Programming">
<meta name="description" content="ソフトウェア工学IIのホームページ">
<meta name="author" content="AOKI Atsushi">
<link rev="made" href="index.html">
<link rel="index" href="index.html">
<style type="text/css">
<!--
body {
  background-color : #ffffff;
  margin : 20px;
  padding : 10px;
  font-family : serif;
  font-size : 10pt;
}
a {
  text-decoration : underline;
  color : #000000;
}
a:link {
  background-color : #ffddbb;
}
a:visited {
  background-color : #ccffcc;
}
a:hover {
  background-color : #dddddd;
}
a:active {
  background-color : #dddddd;
}
div.belt {
  background-color : #eeeeee;
  padding : 0px 4px;
}
div.belt-yellow {
  background-color : #ffffcc;
  padding : 0px 4px;
}
div.belt-blue {
  background-color : #ddeeff;
  padding : 0px 4px;
}
div.right-small {
  text-align : right;
  font-size : 8pt;
}
img.border {
  border-width : 1px;
  border-color : #000000;
  vertical-align : middle;
}
img.borderless {
  border-width : 0px;
  vertical-align : middle;
}
p.belt {
  background-color : #ffeedd;
  padding : 4px 8px;
}
p.belt-blue {
  background-color : #ddeeff;
  padding : 4px 8px;
}
pre.belt {
  background-color : #ddeeff;
  padding : 4px 8px;
}
pre.belt-yellow {
  background-color : #ffffcc;
  padding : 4px 8px;
}
table {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  font-family : serif;
  font-size : 10pt;
}
table.profile {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  font-family : serif;
  font-size : 10pt;
  margin-top : 8px;
  margin-left : 8px;
  margin-right : 8px;
  margin-bottom : 8px;
}
table.belt {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  background-color : #ffeedd;
  padding : 0px 0px;
  width : 100%;
}
table.content {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 2px 4px;
}
table.font-fixed {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 2px 4px;
  font-family : monospace;
}
table.nest {
  border-style : solid;
  border-width : 0px;
  border-color : #000000;
  padding : 0px 0px;
}
td {
  padding : 0px 0px;
  vertical-align : middle;
}
td.center {
  text-align : center;
}
td.center-half {
  text-align : center;
  width : 50%;
  font-size : 8pt;
}
td.center-small {
  text-align : center;
  font-size : 8pt;
  padding : 0px 4px;
}
td.center-small-nopadding {
  text-align : center;
  font-size : 8pt;
  padding : 0px 0px;
}
td.center-white {
  text-align : center;
  background-color : #ffffff;
}
td.center-small-white {
  text-align : center;
  font-size : 8pt;
  background-color : #ffffff;
}
td.center-border1 {
  text-align : center;
  vertical-align : middle;
  empty-cells : show;
  border-style : solid;
  border-width : 1px;
  border-color : #ffc080;
  width : 22px;
  height : 22px;
}
td.left-small {
  text-align : left;
  font-size : 8pt;
  padding : 0px 4px;
}
td.left-small-white {
  text-align : left;
  font-size : 8pt;
  padding : 0px 4px;
  background-color : #ffffff;
}
td.right-small {
  text-align : right;
  font-size : 8pt;
  padding : 0px 4px;
}
td.right-small-white {
  text-align : right;
  font-size : 8pt;
  padding : 0px 4px;
  background-color : #ffffff;
}
th {
  padding : 0px 0px;
  vertical-align : middle;
}
#menu {
  margin: 0px 0px 0px 0px;
  padding: 0px;
  height: 32px;
}
#menu ul {
  margin: 0px;
  padding: 0px;
  list-style: none;
  text-align: center;
  clear: both;
}
#menu li {
  margin: 0px 5px 0px 0px;
  padding: 0px;
  float: left;
}
#menu a {
  display: block;
  padding: 2px 4px;
  text-decoration: none;
  margin: 0px;
  font-weight: bold;
  background: #FFFFFF;
  color: #333333;
  border: 1px solid #666666;
}
#menu a:hover {
  display: block;
  padding: 2px 4px;
  border-bottom: 1px solid #000000;
  text-decoration: none;
  background: #FFCC66;
}
#menu .current {
  background-color: #F45F57;
  font-weight: bold;
  color: #FFFFFF;
  border: 1px solid #333333;
}
-->
</style>
<title>ソフトウェア工学II「樹状整列」プログラム</title>
</head>
<body>
<div id="menu">
<ul>
  <li><a href="../index.html">ホーム</a></li>
  <li><a href="../Requirement/index.html">要求仕様書</a></li>
  <li><a href="../DevelopmentPlan/index.html">開発計画書</a></li>
  <li><a href="../BasicDesign/index.html">基本設計書</a></li>
  <li><a href="../DetailDesign/index.html">詳細設計書</a></li>
  <li><a href="../TestSpecification/index.html">テスト仕様書</a></li>
  <li><a href="../TestResult/index.html">テスト結果</a></li>
  <li><a href="../DevelopmentResult/index.html">開発実績</a></li>
  <li><a href="../Program/index.html" class="current">プログラム</a></li>
  <li><a href="../Manual/index.html">マニュアル</a></li>
</ul>
</div>
<hr>
<h2>ソフトウェア工学II「樹状整列」プログラム</h2>
<ul>
 <li><a href="#Branch">Branch</a>（ブランチ）</li>
 <li><a href="#Constants">Constants</a>（コンスタンツ）</li>
 <li><a href="#Example">Example</a>（メインクラス）</li>
 <li><a href="#Forest">Forest</a>（フォレスト）</li>
 <li><a href="#Node">Node</a>（ノード）</li>
 <li><a href="#TreeModel">TreeModel</a>（モデル）</li>
 <li><a href="#TreeView">TreeView</a>（ビュー）</li>
 <li><a href="#TreeController">TreeController</a>（コントローラー）</li>
 <li><a href="#build">build</a>（ビルドファイル）</li>
 <li><a href="#forest">forest</a>（マニフェストファイル）</li>
 <li><a href="#Makefile">Makefile</a>（メイクファイル）</li>
</ul>
<div class="belt">
<h3><a name="KanseiSaseteKudasai">プログラムのソースコード</a></h3>
</div>
<div >
    <h3><a name="Branch" href ="https://github.com/Fujiya-San/Forest/blob/master/Forest_Program/forest/Branch.java"><pre class = "belt-yellow">Branch</pre></a></h3>
</div>
<pre>
package forest;

import java.awt.Graphics;

/**
 * 樹状整列におけるブランチ（枝）を担うクラスになります。
 */
public class Branch extends Object {

	/**
	 * ブランチ（枝）の始点となるノードを記憶するフィールドです。
	 * 良好（2019/7/29）
	 */
	private Node start;

	/**
	 * ブランチ（枝）の終点となるノードを記憶するフィールドです。
	 * 良好（2019/7/29）
	 */
	private Node end;

	/**
	 * インスタンスを生成する。
	 * @param from 元のノード(親)
	 * @param to 新たなノード(子)
	 * 良好（2019/7/29）
	 */
	public Branch(Node from, Node to) {
		this.start = from;
		this.end = to;
		return;
	}

	/**
	 * 描写メソッド
	 * @param aGraphics 描画引数
	 * 良好（2019/7/29）
	 */
	public void draw(Graphics aGraphics) {
		Integer startX = this.start.getBounds().x + this.start.getBounds().width;
		Integer startY = this.start.getBounds().y + (this.start.getBounds().height / 2);
		Integer endX = this.end.getBounds().x;
		Integer endY = this.end.getBounds().y + (this.end.getExtent().y / 2);
		aGraphics.drawLine(startX, startY, endX, endY);
		return;
	}

	/**
	 * 元ノードを応答
	 * @return 元ノード
	 * 良好（2019/7/29）
	 */
	public Node start() {
		return this.start;
	}

	/**
	 * 新たなノード
	 * @return 新たなノード
	 * 良好（2019/7/29）
	 */
	public Node end() {
		return this.end;
	}

	/**
	 * 自分自身を文字列に変換するメソッドです。
	 * @return 自分自身を表す文字列
	 * 良好（2019/7/29）
	 */
	public String toString() {
		StringBuffer aBuffer = new StringBuffer();
		Class<?> aClass = this.getClass();
		aBuffer.append(aClass.getName());
		aBuffer.append(" [親ノード：");
		aBuffer.append(this.start.getName());
		aBuffer.append(", 子ノード：");
		aBuffer.append(this.end.getName());
		aBuffer.append("]");
		return aBuffer.toString();
	}

}
</pre>
<div >
    <h3><a name="Constants" href="https://github.com/Fujiya-San/Forest/blob/master/Forest_Program/forest/Constants.java"><pre class = "belt-yellow">Constants</pre></a></h3>
</div>
<pre>
package forest;

import java.awt.Color;
import java.awt.Font;
import java.awt.Point;

/**
 * 定数たち：すべてパブリック＆スタティック＆ファイナルの宣言で、このクラスのクラス変数（フィールド）としてアクセス（読み取りが）できます。 樹状整列で用いるリテラル（定数）項の散在を防止するために、このクラスにまとめています。
 */
public class Constants extends Object {

	/**
	 * 樹状整列データファイル中のタグ「ツリー」を表します。
	 * 良好（2019/7/29）
	 */
	public static String TagOfTrees = "trees:";

	/**
	 * 樹状整列データファイル中のタグ「ノード」を表します。
	 * 良好（2019/7/29）
	 */
	public static String TagOfNodes = "nodes:";

	/**
	 * 樹状整列データファイル中のタグ「ブランチ」を表します。
	 * 良好（2019/7/29）
	 */
	public static String TagOfBranches = "branches:";

	/**
	 * ノードを描く際のラベルの文字色を表します。
	 * 良好（2019/7/29）
	 */
	public static Color ForegroundColor = Color.black;

	/**
	 * ノードを描く際のラベルの背景色を表します。
	 * 良好（2019/7/29）
	 */
	public static Color BackgroundColor = Color.white;

	/**
	 * ノードを描く際のラベルのフォントを表します。
	 * 良好（2019/7/29）
	 */
	public static Font DefaultFont = new Font("Serif", Font.PLAIN, 12);

	/**
	 * ノードにおいてラベルを描く際の枠縁から余裕（マージン）を表します。
	 * 良好（2019/7/29）
	 */
	public static Point Margin = new Point(2,1);

	/**
	 * ノード群を樹状に整列させる際にノード同士の間隔を表します。
	 * 良好（2019/7/29）
	 */
	public static Point Interval = new Point(25,2);

	/**
	 * ノード群を深さ優先にたどる際の状態「未定」を表します。
	 * 良好（2019/7/29）
	 */
	public static Integer UnKnown = -1;

	/**
	 * ノード群を深さ優先にたどる際の状態「未訪問」を表します。
	 * 良好（2019/7/29）
	 */
	public static Integer UnVisited = 0;

	/**
	 * ノード群を深さ優先にたどる際の状態「訪問済」を表します。
	 * 良好（2019/7/29）
	 */
	public static Integer Visited = 1;

	/**
	 * 樹状整列アニメーションのチックタック：時間間隔：スピードを表します。
	 * 良好（2019/7/29）
	 */
	public static Integer SleepTick = 100;
}
</pre>
<div >
    <h3><a name="Example" href="https://github.com/Fujiya-San/Forest/blob/master/Forest_Program/forest/Example.java"><pre class = "belt-yellow">Example</pre></a></h3>
</div>
<pre>
package forest;

import java.awt.Dimension;
import java.awt.Point;
import java.awt.Container;
import java.io.File;
import javax.swing.JFrame;

/**
 * 樹状整列の例題クラス：使い方の典型を示すのが目的のプログラムです。<br>
 * Makefileを用いた実行方法は以下の通りです。<br>
 * $ make tree  # 木を整列描画<br>
 * $ make forest  # 森を整列描画<br>
 * $ make semilattice  # 亜格子状の森を整列描画<br>
 */
public class Example extends Object
{
	/**
	 * 第1引数で樹状整列データファイルを受け取って樹状整列を実行します。<br>
	 * $ java -Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar forest.jar resource/data/tree.txt<br>
	 * $ java -Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar forest.jar resource/data/forest.txt<br>
	 * $ java -Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar forest.jar resource/data/semilattice.txt<br>
	 * @param arguments 樹状整列データファイルを第1引数とする引数文字列群
	 * 良好（2019/7/29）
	 */
	public static void main(String[] arguments)
	{
		// 引数が無い（樹状整列データファイルの在り処がわからない）をチェックする。
		if (arguments.length < 1)
		{
			System.err.println("There are too few arguments.");
			System.exit(1);
		}

		// 第1引数で指定された樹状整列データファイルの存在をチェックする。
		File aFile = new File(arguments[0]);
		if (!(aFile.exists()))
		{
			System.err.println("'" + aFile + "' does not exist.");
			System.exit(1);
		}

		 // MVCを作成する。
		TreeModel aModel = new TreeModel(aFile);
		TreeView aView = new TreeView(aModel);
		aView.setFont(Constants.DefaultFont);

		// ウィンドウを生成して開く。
		JFrame aWindow = new JFrame(aFile.getName());
		aWindow.getContentPane().add(aView);
		aWindow.setMinimumSize(new Dimension(400, 300));
		aWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		aWindow.setSize(800, 600);
		aWindow.setLocationRelativeTo(null);
		aWindow.setVisible(true);

		// 樹状整列のアニメーションを行う。
		aModel.animate();

		return;
	}
}
</pre>
<div >
    <h3><a name="Forest" href="https://github.com/Fujiya-San/Forest/blob/master/Forest_Program/forest/Forest.java"><pre class = "belt-yellow">Forest</pre></a></h3>
</div>
<pre>
package forest;

import java.util.Objects;
import java.util.Vector;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.awt.Component;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import mvc.Model;

/**
 * 樹状整列におけるフォレスト（木・林・森・亜格子状の森）を担うクラスになります。
 */
public class Forest extends Object {

	/**
	 * ノード（節）群（たち）を記憶するフィールドです。
	 * 良好（2019/7/29）
	 */
	private ArrayList<Node> nodes = new ArrayList<>();

	/**
	 * ルートノードを記憶するフィールドです。
	 * 良好（2019/7/29）
	 */
	private ArrayList<Node> rootNodesList = new ArrayList<>();

	/**
	 * ブランチ（枝）群（たち）を記憶するフィールドです。
	 * 良好（2019/7/29）
	 */
	private ArrayList<Branch> branches = new ArrayList<>();

	/**
	 * 樹状整列したフォレスト（森）の領域（矩形）を記憶するフィールドです。
	 * 良好（2019/7/29）
	 */
	private Rectangle bounds = new Rectangle();

	/**
	 * 木構造をString型で記憶するフィールドです。
	 * 良好（2019/7/29）
	 */
	private String forestForm;

	/**
	 * ブランチ（枝）を追加するメソッドです。
	 * @param aBranch ノード（節）
	 * 良好（2019/7/29）
	 */
	public void addBranch(Branch aBranch) {
		branches.add(aBranch);
		return;
	}

	/**
	 * ノード（節）を追加するメソッドです。
	 * @param aNode ノード（節）
	 * 良好（2019/7/29）
	 */
	public void addNode(Node aNode) {
		nodes.add(aNode);
		return;
	}

	/**
	 * 樹状整列するトップ（一番上位）のメソッドです。アニメーション無しで樹状整列させます。
	 * 良好（2019/7/29）
	 */
	public void arrange() {
		this.initSet();
		Consumer<Node> aConsumer = (Node aNode) -> {
			if(Objects.equals(aNode, this.rootNodesList.get(0))) this.arrange(aNode, new Point(this.bounds.x+Constants.Margin.x, this.bounds.y+this.bounds.height+aNode.getBounds().height-Constants.Margin.y-Constants.Margin.y), null);
			else System.out.println(this.arrange(aNode, new Point(this.bounds.x+Constants.Margin.x, this.bounds.y+this.bounds.height+aNode.getBounds().height-Constants.Margin.y-Constants.Margin.y+Constants.Interval.y), null));
		};
		this.rootNodesList.forEach( aConsumer );
		return;
	}

	/**
	 * 樹状整列するセカンドレベル（二番階層）のメソッドです。
	 * @param aModel モデル
	 * 良好（2019/7/29）
	 */
	public void arrange(TreeModel aModel) {
		this.bounds.setSize(0, 0);
		this.rootNodes();
		Consumer<Node> aConsumer = (Node aNode) -> {
			if(Objects.equals(aNode, this.rootNodesList.get(0))) this.arrange(aNode, new Point(this.bounds.x+Constants.Margin.x, this.bounds.y+this.bounds.height+aNode.getBounds().height-Constants.Margin.y-Constants.Margin.y), aModel);
			else System.out.println(this.arrange(aNode, new Point(this.bounds.x+Constants.Margin.x, this.bounds.y+this.bounds.height+aNode.getBounds().height-Constants.Margin.y-Constants.Margin.y+Constants.Interval.y), aModel));
		};
		rootNodesList.forEach( aConsumer );
		return;
	}

	/**
	 * 樹状整列する再帰レベル（N番階層）のメソッドです。
	 * @param  aNode  ノード（このノードから再帰的にたどって下位のものたちも整列する）
	 * @param  aPoint ノードの位置（座標）
	 * @param  aModel モデル（nullのときはアニメーションを行わない）
	 * @return        樹状整列に必要だった大きさ（幅と高さ）
	 * 良好（2019/7/29）
	 */
	protected Point arrange(Node aNode, Point aPoint,  TreeModel aModel)
	{
		// 現在のノードのサブノードを求めて、ソートする
		ArrayList<Node> subNodes = this.subNodes(aNode);
		subNodes = this.sortNodes(subNodes);

		// ノードの位置を更新する
		aNode.setLocation(aPoint);

		// モデルが変化したことを伝える
		if(aModel != null) this.propagate(aModel);

		// 描画領域の範囲を更新する
		if(this.bounds.x+this.bounds.width < aNode.getBounds().x+aNode.getBounds().width) this.bounds.setSize(aNode.getBounds().width+aNode.getBounds().x-this.bounds.x, this.bounds.height);
		if(this.bounds.y+this.bounds.height < aNode.getBounds().y+aNode.getBounds().height) this.bounds.setSize(this.bounds.width, aNode.getBounds().y+aNode.getBounds().height-this.bounds.y);

		// サブノードとその座標を引数として渡して再帰呼び出しする。
		Integer anIndex = 0;
		for(Node aSubNode : subNodes)
		{
			if(!Objects.equals(aSubNode.getStatus(), Constants.Visited) && anIndex == 0)
			{
				this.arrange(aSubNode, new Point(aNode.getBounds().x+aNode.getBounds().width+Constants.Interval.x+Constants.Margin.x, this.bounds.y+this.bounds.height-Constants.Margin.y-Constants.Margin.y), aModel);
			}else if(!Objects.equals(aSubNode.getStatus(), Constants.Visited))
			{
				this.arrange(aSubNode, new Point(aNode.getBounds().x+aNode.getBounds().width+Constants.Interval.x+Constants.Margin.x, this.bounds.y+this.bounds.height+aNode.getBounds().height-Constants.Margin.y-Constants.Margin.y+Constants.Interval.y), aModel);
			}
			anIndex++;

		}

		// サブノード群の高さの半分の高さにノードの位置をセットする
		aNode.setLocation(new Point(aPoint.x, aNode.getBounds().y+((this.bounds.y+this.bounds.height-aNode.getBounds().y)/2)+(aNode.getBounds().height/2)-Constants.Margin.y));

		// モデルが変更されたことを伝える
		if(aModel != null) this.propagate(aModel);

		// ノードのステータスを訪問済みにセットする
		aNode.setStatus(Constants.Visited);

		return new Point(this.bounds.width, this.bounds.height);
	}

	/**
	 * フォレスト（木・林・森・亜格子状の森）の領域（矩形）を応答するメソッドです。
	 * @return フォレスト領域（矩形）
	 * 良好（2019/7/29）
	 */
	public Rectangle bounds()
	{
		return this.bounds;
	}

	/**
	 * フォレスト（木・林・森・亜格子状の森）を描画するメソッドです。
	 * @param aGraphics グラフィクス（描画コンテクスト）
	 * 良好（2019/7/29）
	 */
	public void draw(Graphics aGraphics)
	{
		nodes.forEach(aNode -> aNode.draw(aGraphics));
		branches.forEach(aBranch -> aBranch.draw(aGraphics));
		// aGraphics.drawRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
		return;
	}

	/**
	 * フォレスト（木・林・森・亜格子状の森）の領域（矩形）を水に流す（チャラにする）メソッドです。
	 * 良好（2019/7/29）
	 */
	public void flushBounds()
	{
		this.bounds = new Rectangle();
		return;
	}

	/**
	 * チックタックの間、スリープし、モデルが変化した、と騒ぐ（広める：放送する）メソッドです。
	 * @param aModel モデル
	 * 修正（2019/7/29）
	 * 良好（2019/7/29）
	 */
	protected void propagate(TreeModel aModel)
	{
		try
		{
			Thread.sleep(Constants.SleepTick);
		}catch(InterruptedException e)
		{
			e.printStackTrace();
		}
		aModel.changed();
		return;
	}

	/**
	 * スクロールされた際、矩形を移動させるメソッドです。
	 * @param aPoint X軸とY軸の絶対スクロール量を表す座標
	 * 良好（2019/7/29）
	 */
	public void moveBounds(Point aPoint)
	{
		this.bounds.setLocation(this.bounds.x+aPoint.x, this.bounds.y+aPoint.y);
		return;
	}

	/**
	 * ノードのステータスと描画領域の矩形の大きさを初期化メソッドです。
	 * 良好（2019/7/29）
	 */
	protected void initSet()
	{
		this.bounds.setSize(0, 0);
		Consumer<Node> aConsumer = (Node aNode) -> { aNode.setStatus(Constants.UnVisited); };
		this.nodes.forEach(aConsumer);
		return;
	}

	/**
	 * フォレストの根元（ルート）となるノード群を応答するメソッドです。
	 * @return ルートノード群
	 * 良好（2019/7/29）
	 */
	public ArrayList<Node> rootNodes()
	{
		if(this.rootNodesList.size() == 0)
		{
			Integer anIndex = 0;
			for(Node aNode : nodes)
			{
				anIndex = 0;
				for(Branch aBranch : branches)
				{
					if(Objects.equals(aNode.getName(), aBranch.end().getName())) break;
					else if(anIndex == branches.size()-1) this.rootNodesList.add(aNode);
					anIndex++;
				}
			}
			rootNodesList = this.sortNodes(rootNodesList);
			return this.rootNodesList;
		}
		else
		{
			return this.rootNodesList;
		}

	}

	/**
	 * 引数で指定されたノード群をノード名でソート（並び替えを）するメソッドです。
	 * @param  nodeCollection ノード群
	 * @return                ソートされたノード群
	 * 良好（2019/7/29）
	 */
	protected ArrayList<Node> sortNodes(ArrayList<Node> nodeCollection)
	{
		nodeCollection.sort( (node1, node2) -> node1.getName().compareTo(node2.getName()) );
		return nodeCollection;
	}

	/**
	 * 引数で指定されたノードのサブノード群を応答するメソッドです。
	 * @param  aNode ノード
	 * @return       サブノード群
	 * 良好（2019/7/29）
	 */
	public ArrayList<Node> subNodes(Node aNode)
	{
		ArrayList<Node> subNodesList = new ArrayList<>();
		for(Branch aBranch : branches)
		{
			if(Objects.equals(aBranch.start(), aNode))
			{
				subNodesList.add(aBranch.end());
			}
		}
		return subNodesList;
	}

	/**
	 * 引数で指定されたノードのサブノード群を応答するメソッドです。
	 * @param  aNode ノード
	 * @return       サブノード群
	 * 良好（2019/7/29）
	 */
	public ArrayList<Node> superNodes(Node aNode)
	{
		ArrayList<Node> superNodesList = new ArrayList<>();
		for(Branch aBranch : branches)
		{
			if(Objects.equals(aBranch.end(), aNode))
			{
				superNodesList.add(aBranch.start());
			}
		}
		return superNodesList;
	}

	/**
	 * 木構造をセットするメソッドです。
	 * @param form テキストファイルから読み込んだ木構造の文字列
	 * 良好（2019/7/29）
	 */
	public void setForm(String form)
	{
		this.forestForm = form;
		return;
	}

	/**
	 * 自分自身を文字列に変換するメソッドです。
	 * @return 自分自身を表す文字列
	 * 良好（2019/7/29）
	 */
	public String toString() {
		StringBuffer aBuffer = new StringBuffer();
		Class<?> aClass = this.getClass();
		aBuffer.append(aClass.getName());
		aBuffer.append(System.getProperty("line.separator"));
		aBuffer.append(this.forestForm);
		return aBuffer.toString();
	}

	/**
	 * 指定された位置（座標）にノードが存在するかを調べるメソッドです。
	 * @param  aPoint 位置（モデル座標）
	 * @return        ノード、もしも見つからなかった場合には、nullを応答します。
	 * 良好（2019/7/29）
	 */
	public Node whichOfNodes(Point aPoint)
	{
		Predicate<Node> aPredicate = (Node aNode) -> {return aNode.getBounds().contains(aPoint); };
		return nodes.stream().filter(aPredicate).findFirst().orElse(null);

	}

}
</pre>
<div >
    <h3><a name="Node" href="https://github.com/Fujiya-San/Forest/blob/master/Forest_Program/forest/Node.java"><pre class = "belt-yellow">Node</pre></a></h3>
</div>
<pre>
package forest;

import java.awt.Component;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.FontMetrics;

/**
 * 樹状整列におけるノード（節）を担うクラスになります。
 */
@SuppressWarnings("serial")
public class Node extends Component
{
	/**
	 * ノード名：ラベル文字列を記憶するフィールドです。
	 * 良好 (7月29日)
	 */
	private String name;

	/**
	 * ノードの場所（位置：座標）を記憶するフィールドです。
	 * 良好 (7月29日)
	 */
	private Point location;

	/**
	 * ノードの大きさ（幅と高さ）を記憶するフィールドです。
	 * 良好 (7月29日)
	 */
	private Point extent;

	/**
	 * 樹状整列する際のノードの状態を記憶するフィールドです。
	 * 良好 (7月29日)
	 */
	private Integer status;

	/**
	 * ノードを囲む矩形を記憶するフィールドです。
	 * 良好 (7月29日)
	 */
	private Rectangle bounds;

	/**
	 * このクラスのインスタンスを生成するコンストラクタです。
	 * @param  aString ノード名：ラベル文字列
	 * 良好 (7月29日)
	 */
	public Node(String aString)
	{
		this.setName(aString);
		this.bounds = new Rectangle();
		this.setExtent(new Point(this.stringWidth(aString), this.stringHeight(aString)));
		return;
	}

	/**
	 * ノード（節）を描画するメソッドです。
	 * @param aGraphics グラフィクス（描画コンテクスト）
	 * 良好　(7月２９日)
	 */
	public void draw(Graphics aGraphics)
	{
		aGraphics.drawRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
		aGraphics.drawString(this.name, this.location.x, this.location.y);
		return;
	}

	/**
	 * ノード（節）の描画領域を応答するメソッドです。
	 * @return ノード（節）の描画領域（Rectangleのインスタンス）
	 * 良好 (7月29日)
	 */
	public Rectangle getBounds()
	{
		return this.bounds;
	}

	/**
	 * ノード（節）の大きさを応答するメソッドです。
	 * @return ノード（節）の大きさ（幅と高さ）
	 * 良好 (7月29日)
	 */
	public Point getExtent()
	{
		return this.extent;
	}

	/**
	 * ノード（節）の位置を応答するメソッドです。
	 * @return ノード（節）の位置（座標）
	 * 良好 (7月29日)
	 */
	public Point getLocation()
	{
		return this.location;
	}

	/**
	 * ノード（節）の名前を応答するメソッドです。
	 * @return ノード名（ラベル文字列）
	 * 良好　(7月29日)
	 */
	public String getName()
	{
		return this.name;
	}

	/**
	 * ノード（節）の状態を応答するメソッドです。
	 * @return ノードの状態
	 * 良好 (7月29日)
	 */
	public Integer getStatus()
	{
		return this.status;
	}

	/**
	 * ノード（節）の大きさを設定するメソッドです。
	 * @param aPoint ノードの大きさ（幅と高さ）
	 * 良好（2019/7/29）
	 */
	public void setExtent(Point aPoint)
	{
		this.extent = aPoint;
		this.bounds.setSize(aPoint.x+Constants.Margin.x*2, aPoint.y+Constants.Margin.y);
		return;
	}

	/**
	 * ノード（節）の位置を設定するメソッドです。
	 * @param aPoint ノードの位置（座標）
	 * 良好（2019/7/29）
	 */
	public void setLocation(Point aPoint)
	{
		this.location = aPoint;
		this.bounds.setLocation(aPoint.x-Constants.Margin.x, aPoint.y-this.stringHeight(this.name)+Constants.Margin.y);
		return;
	}

	/**
	 * ノード（節）の名前を設定するメソッドです。
	 * @param aString ノードの名前（ラベル）
	 * 良好 (7月29日)
	 */
	public void setName(String aString)
	{
		this.name = aString;
		return;
	}

	/**
	 * ノード（節）の状態を設定するメソッドです。
	 * @param anInteger ノードの状態
	 * 良好 (7月29日)
	 */
	public void setStatus(Integer anInteger)
	{
		this.status = anInteger;
		return;
	}

	/**
	 * 文字列の高さを応答するメソッドです。
	 * @param  string 文字列
	 * @return        文字列の高さ
	 * 良好 (7月29日)
	 */
	protected int stringHeight(String string)
	{
		FontMetrics aFontMetrics = super.getFontMetrics(Constants.DefaultFont);
		return aFontMetrics.getHeight();
	}

	/**
	 * 文字列の幅を応答するメソッドです。
	 * @param  string 文字列
	 * @return        文字列の幅
	 * 良好（2019/7/29）
	 */
	protected int stringWidth(String string)
	{
		FontMetrics aFontMetrics = super.getFontMetrics(Constants.DefaultFont);
		return aFontMetrics.stringWidth(string);
	}

	/**
	 * 自分自身を文字列に変換するメソッドです。
	 * @return 自分自身を表す文字列
	 * 良好 (7月29日)
	 */
	public String toString()
	{
		return this.name;
	}

}
</pre>
<div >
    <h3><a name="TreeModel" href="https://github.com/Fujiya-San/Forest/blob/master/Forest_Program/forest/TreeModel.java"><pre class = "belt-yellow">TreeModel</pre></a></h3>
</div>
<pre>
package forest;

import java.io.File;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Objects;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.HashMap;
import java.awt.Point;
import mvc.Model;

/**
* 樹状整列におけるMVCのモデル（M）を担うクラスになります。
*/

public class TreeModel extends Model {

	/**
	* 樹状整列それ自身を記憶しておくフィールドです。
	* 良好 (7月29日)
	*/
	private Forest forest;

	/**
	* 依存物 TreeViewのインスタンスたちを束縛する。
	* 良好　(7月29日)
	*/
	protected ArrayList<TreeView> dependents;


	/**
	* このクラスのインスタンスを生成するコンストラクタです。
	* @param  aFile 樹状整列データファイル
	* 良好　(7月29日)
	*/
	public TreeModel(File aFile)
	{
		super();
		this.dependents = new ArrayList<TreeView>();
		this.forest = new Forest();
		this.read(aFile);
		return;
	}


	/**
	* 指定されたビューを依存物に設定する
	* @param aView このモデルの依存物となるビュー
	* 良好　(7月29日)
	*/
	public void addDependent(TreeView aView)
	{
		dependents.add(aView);
		return;
	}


	/**
	* アニメーションを行うメソッドです。
	* 良好 (7月29日)
	*/
	public void animate()
	{
		this.arrange();
		// System.out.println(this.forest.toString());
		return;
	}

	/**
	* 初期化する。
	* 良好 (7月29日)
	*/
	private void initialize()
	{
		dependents = new ArrayList<TreeView>();
		forest = null;
		return;
	}

	/**
	* 樹状整列を行うメソッドです。
	* 良好　(7月29日)
	*/
	public void arrange()
	{
		this.forest.arrange(this);
		return;
	}

	/**
	* モデルの内部状態が変化していたので、自分の依存物へupdateのメッセージを送信する。
	* 良好　(7月29日)
	*/
	public void changed()
	{
		dependents.forEach((TreeView aView) -> { aView.paintComponent(aView.getGraphics());});
		return;
	}

	/**
	* 樹状整列をそれ自身を応答するメソッドです。
	* @return 樹状整列それ自身
	* 良好　(7月29日)
	*/
	public Forest forest()
	{
		return this.forest;
	}

	/**
	* ファイルを読み込み、forestのインスタンスを作成する。
	* @param aFile
	* 修正　(7月29日)
	* 良好　(7月29日)
	*/
	protected void read(File aFile)
	{
		try
		{
			Boolean treesDataFlag = false;
			Boolean nodesDataFlag = false;
			Boolean branchesDataFlag = false;
			Boolean isNumberFlag = true;
			StringBuffer aBuffer = new StringBuffer();
			BufferedReader in = new BufferedReader(new FileReader(aFile));
			HashMap<String, Node> nodeMap = new HashMap<>();
			String line;

			while((line = in.readLine()) != null)
			{
				String[] data = line.split(", ");

				if(Objects.equals(line, Constants.TagOfTrees))
				{
					treesDataFlag = true;
					nodesDataFlag = false;
					branchesDataFlag = false;
				}else if(Objects.equals(line, Constants.TagOfNodes))
				{
					treesDataFlag = false;
					nodesDataFlag = true;
					branchesDataFlag = false;
				}else if(Objects.equals(line, Constants.TagOfBranches))
				{
					treesDataFlag = false;
					nodesDataFlag = false;
					branchesDataFlag = true;
				}else
				{
					if(treesDataFlag)
					{
						aBuffer.append(data[0]);
						aBuffer.append(System.getProperty("line.separator"));
					}
					if(nodesDataFlag)
					{
						try
						{
			                Integer.parseInt(data[0]);
			            }
			            catch (NumberFormatException e)
			            {
			            	e.printStackTrace();
			                isNumberFlag = false;
			            }
						if(isNumberFlag && data.length > 1)
						{
							Node aNode = new Node(data[1]);
							aNode.setLocation(new Point(0, Integer.valueOf(data[0])*Constants.DefaultFont.getSize()));
							aNode.setStatus(Constants.UnVisited);
							nodeMap.put(data[0], aNode);
							this.forest.addNode(aNode);
						}

					}
					if(branchesDataFlag)
					{
						try
						{
			                Integer.parseInt(data[0]);
			                if(data.length > 1) Integer.parseInt(data[1]);
			            } catch (NumberFormatException e)
			            {
			            	e.printStackTrace();
			                isNumberFlag = false;
			            }
			            if(isNumberFlag && data.length > 1)
			            {
			            	if(nodeMap.get(data[0]) != null && nodeMap.get(data[1]) != null) this.forest.addBranch(new Branch(nodeMap.get(data[0]), nodeMap.get(data[1])));
			            }
					}
				}
				isNumberFlag = true;
			}
			this.forest.setForm(aBuffer.toString());
		}catch(Exception e)
		{
			e.printStackTrace();
		}
		return;
	}

	/**
	* 樹状整列の根源(ルート)になるノードを探し出して応答するメソッドです。
	* @return
	* 良好　(7月29日)
	*/
	public Node root()
	{
		return this.forest.rootNodes().get(0);
	}

	/**
	* 樹状整列の根源(ルート)になるノードたちを探し出して応答するメソッドです。
	* @return
	* 良好　(7月29日)
	*/
	public ArrayList<Node> roots() {
		return this.forest.rootNodes();
	}

}
</pre>
<div >
    <h3><a name="TreeView" href="https://github.com/Fujiya-San/Forest/blob/master/Forest_Program/forest/TreeView.java"><pre class = "belt-yellow">TreeView</pre></a></h3>
</div>
<pre>
package forest;

import java.awt.Graphics;
import java.awt.Point;
import mvc.View;

/**
 * 樹状整列におけるMVCのビュー（V）を担うクラスになります。
 */
@SuppressWarnings("serial")
public class TreeView extends View
{

	/**
	 * 情報を握っているTreeModelのインスタンスを束縛する。
	 * 良好 (7月29日)
	 */
	protected TreeModel model;

	/**
	 * 制御を司るTreeControllerのインスタンスを束縛する。
	 * 良好 (7月29日)
	 */
	protected TreeController controller;

	/**
	 * このクラスのインスタンスを生成するコンストラクタです。
	 * @param  aModel モデル（Modelのインスタンス）
	 * 良好 (7月29日)
	 */
	public TreeView(TreeModel aModel)
	{
		super(aModel);
		model = aModel;
		model.addDependent(this);
		controller = new TreeController();
		controller.setModel(model);
		controller.setView(this);
		return;
	}

	/**
	 * このパネル（ビュー）の描画が必要になったときに動作するメソッドです。
	 * @param aGraphics グラフィクス（描画コンテクスト）
	 * 良好 (7月29日)
	 */
	public void paintComponent(Graphics aGraphics)
	{
		this.update();
		this.model.forest().draw(aGraphics);
		return;
	}

	/**
	 * スクロール量を指定された座標分だけ相対スクロールする。
	 * @param aPoint X軸とY軸のスクロール量を表す座標
	 * 良好 (7月29日)
	 */
	public void scrollBy2(Point aPoint)
	{

		int x = aPoint.x;
		int y = aPoint.y;
		model.forest().moveBounds(new Point(x, y));
		this.model.forest().arrange();
		return;
	}

	/**
	 * 指定された位置（座標）にノードが存在するかを調べるメソッドです。
	 * @param  aPoint 位置（ビュー座標）
	 * @return ノード、もしも見つからなかった場合には、nullを応答します。
	 * 良好 (7月29日)
	 */
	public Node whichOfNodes(Point aPoint)
	{
		return model.forest().whichOfNodes(aPoint);
	}

}
</pre>
<div >
    <h3><a name="TreeController" href="https://github.com/Fujiya-San/Forest/blob/master/Forest_Program/forest/TreeController.java"><pre class = "belt-yellow">TreeController</pre></a></h3>
</div>
<pre>
package forest;

import java.awt.event.MouseEvent;
import mvc.Controller;
import java.awt.Point;
import java.awt.Cursor;
import java.awt.Component;
import java.util.ArrayList;
import java.util.Objects;

/**
 * 樹状整列におけるMVCのコントローラ（C）を担うクラスになります。
 */
public class TreeController extends Controller
{

	/**
	 * 情報を握っているTreeModelのインスタンスを束縛する。
	 * 良好　(7月29日)
	 */
	protected TreeModel model;

	/**
	 * 表示を司るTreeViewのインスタンスを束縛する。
	 * 良好 (7月29日)
	 */
	protected TreeView view;

	/**
	 * 以前にマウスのボタンが押下された場所をPointのインスタンスとして束縛する。
	 * 良好 (7月29日)
	 */
	private Point changePlace;

	/**
	 * 現在にマウスのボタンが押下された場所をPointのインスタンスとして束縛する。
	 * 良好 (7月29日)
	 */
	private Point now;

	/**
	 * インスタンスを生成して応答する。
	 * すべてのインスタンス変数（model, view, changePlace, now）をnull化する。
	 * 良好(7月29日)
	 */
	public TreeController()
	{
		super();
		model = null;
		view = null;
		changePlace = null;
		now = null;
		return;
	}

	/**
	 * 指定されたモデルをインスタンス変数modelに設定する。
	 * @param aModel このコントローラのモデル
	 * 良好 (7月29日)
	 */
	public void setModel(TreeModel aModel)
	{
		model = aModel;
		return;
	}

	/**
	 * マウスカーサの形状を移動の形に変化させ、指定されたマウスイベントからマウスカーサの位置を獲得して、
	 * インスタンス変数changePlaceに設定すると共に、以前のマウスカーサの位置からの差分を計算する。
	 * そして、その差分だけビューに対してスクロールを依頼し、その後にビューの再描画を依頼する。
	 * 最後にインスタンス変数nowをインスタンス変数changePlaceに更新する。
	 * @param aMouseEvent マウスイベント
	 * 良好　(7月29日)
	 */
	public void mouseDragged(MouseEvent aMouseEvent)
	{
		ArrayList<Node> rootNodes = this.model.roots();
		for(Node aNode : rootNodes)
		{
			if(!(Objects.equals(aNode.getStatus(), Constants.Visited))) return;
		}
		Cursor aCursor = Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);
		Component aComponent = (Component)aMouseEvent.getSource();
		aComponent.setCursor(aCursor);
		now = aMouseEvent.getPoint();
		int x = now.x - changePlace.x;
		int y = now.y - changePlace.y;
		Point point = new Point(x, y);
		view.scrollBy2(point);
		view.update();
		changePlace = now;
		return;
	}

	/**
	 * 指定されたビューをインスタンス変数viewに設定し、
	 * ビューのマウスのリスナおよびモーションリスナそしてホイールリスナをこのコントローラにする。
	 * @param aView このコントローラのビュー
	 * 良好　(7月29日)
	 */
	public void setView(TreeView aView)
	{
		view = aView;
		view.addMouseListener(this);
		view.addMouseMotionListener(this);
		view.addMouseWheelListener(this);
		return;
	}

	/**
	 * マウスカーサの形状を十字に変化させ、指定されたマウスイベントからマウスカーサの位置を獲得して、
	 * インスタンス変数nowに設定する共にインスタンス変数changePlaceをインスタンス変数nowに更新する。
	 * @param aMouseEvent マウスイベント
	 * 良好　(7月29日)
	 */
	public void mousePressed(MouseEvent aMouseEvent)
	{
		Cursor aCursor = Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR);
		Component aComponent = (Component)aMouseEvent.getSource();
		aComponent.setCursor(aCursor);
		now = aMouseEvent.getPoint();
		changePlace = now;
		return;
	}

	/**
	 * マウスクリック判定を行うメソッド
	 * @param aMouseEvent マウスのクリック情報
	 * 良好 (7月29日)
	 */
	public void mouseClicked(MouseEvent aMouseEvent)
	{
		Point aPoint = aMouseEvent.getPoint();
		Node aNode = view.whichOfNodes(aPoint);
		if(aNode != null)
		{
			System.out.printf("%s%n", aNode.getName());
		}
		return;
	}
}
</pre>
<div >
    <h3><a name="build" href="https://github.com/Fujiya-San/Forest/blob/master/Forest_Program/build.xml"><pre class = "belt-yellow">build.xml</pre></a></h3>
</div>
<pre>
&lt?xml version="1.0" encoding="UTF-8"?&gt

&ltproject name="Forest" default="all" basedir="."&gt

	&ltproperty name="package" value="forest" /&gt
	&ltproperty name="mvc" value="mvc" /&gt
	&ltproperty name="packagenames" value="${package},${mvc}" /&gt
	&ltproperty name="destdir" value="./Classes" /&gt
	&ltproperty name="docdir" value="./JavaDoc" /&gt
	&ltproperty name="instdir" value="./${ant.project.name}.app/Contents/Resources/Java" /&gt
	&ltproperty name="copyright" value="Copyright 2008-2017 AOKI Atsushi. All Rights Reserved." /&gt
	&ltproperty name="zipname" value="${ant.project.name}" /&gt

	&lttarget name="all" depends="jar" description="build all"&gt
		&ltexec executable="date" spawn="false" /&gt
	&lt/target&gt

	&lttarget name="prepare" depends="" description="prepare to compile"&gt
		&ltmkdir dir="${destdir}" /&gt
		&ltexec executable="date" spawn="false" /&gt
	&lt/target&gt

	&lttarget name="compile" depends="prepare" description="compile all sources"&gt
		&ltjavac
			fork="true"
			srcdir="${basedir}"
			destdir="${destdir}"
			includeAntRuntime="true"
			encoding="UTF-8"
			deprecation="on"
			verbose="false"&gt
			&ltcompilerarg value="-J-Dfile.encoding=UTF8" /&gt
			&ltcompilerarg value="-Xlint:all" /&gt
			&ltclasspath&gt
				&ltpathelement location="." /&gt
				&ltpathelement location="${mvc}.jar" /&gt
			&lt/classpath&gt
		&lt/javac&gt
		&ltexec executable="date" spawn="false" /&gt
	&lt/target&gt

	&lttarget name="jar" depends="compile" description="make jar file"&gt
		&ltjar
			jarfile="${package}.jar"
			basedir="${destdir}"
			manifest="${package}.mf"&gt
			&ltzipfileset src="${mvc}.jar" /&gt
		&lt/jar&gt
		&ltexec executable="date" spawn="false" /&gt
	&lt/target&gt

	&lttarget name="clean" description="cleaning"&gt
		&ltdelete dir="${destdir}" /&gt
		&ltdelete file="${package}.jar" /&gt
		&ltdelete dir="${docdir}" /&gt
		&ltdelete dir="${instdir}" /&gt
		&ltdelete file="../${zipname}.zip" /&gt
		&ltdelete&gt
			&ltfileset dir="${package}" includes="*.class" /&gt
		&lt/delete&gt
		&ltexec executable="date" spawn="false" /&gt
	&lt/target&gt

	&lttarget name="test" depends="all,tree" description="test"&gt
		&ltexec executable="date" spawn="false" /&gt
	&lt/target&gt

	&lttarget name="tree" depends="all" description="tree"&gt
		&ltexec executable="java" spawn="false"&gt
			&ltarg line="-Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar ${package}.jar resource/data/tree.txt" /&gt
		&lt/exec&gt
		&ltexec executable="date" spawn="false" /&gt
	&lt/target&gt

	&lttarget name="forest" depends="all" description="forest"&gt
		&ltexec executable="java" spawn="false"&gt
			&ltarg line="-Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar ${package}.jar resource/data/forest.txt" /&gt
		&lt/exec&gt
		&ltexec executable="date" spawn="false" /&gt
	&lt/target&gt

	&lttarget name="semilattice" depends="all" description="semilattice"&gt
		&ltexec executable="java" spawn="false"&gt
			&ltarg line="-Dfile.encoding=UTF-8 -Xmx512m -Xss1024k -jar ${package}.jar resource/data/semilattice.txt" /&gt
		&lt/exec&gt
		&ltexec executable="date" spawn="false" /&gt
	&lt/target&gt

	&lttarget name="install" depends="all" description="install into application"&gt
		&ltcopy file="${package}.jar" todir="${instdir}" /&gt
		&ltcopy file="resource/data/forest.txt" todir="${instdir}" /&gt
		&ltcopy file="resource/data/tree.txt" todir="${instdir}" /&gt
		&ltcopy file="resource/data/semilattice.txt" todir="${instdir}" /&gt
		&ltexec executable="chmod"&gt
			&ltarg line="755 ${instdir}/../../MacOS/applet" /&gt
		&lt/exec&gt
		&ltexec executable="date" spawn="false" /&gt
	&lt/target&gt

	&lttarget name="doc" depends="all" description="make document (javadoc)"&gt
		&ltmkdir dir="${docdir}" /&gt
		&ltjavadoc
			locale="ja_JP"
			sourcepath="${basedir}"
			destdir="${docdir}"
			packagenames="${packagenames}"
			author="true"
			version="true"
			charset="UTF-8"
			encoding="UTF-8"
			docencoding="UTF-8"
			linksource="yes"
			additionalparam="-J-Dfile.encoding=UTF-8"
			access="private"&gt
			&ltdoctitle&gt${doc-title}&lt/doctitle&gt
			&ltbottom&gt${copyright}&lt/bottom&gt
			&ltclasspath&gt
				&ltpathelement location="." /&gt
				&ltpathelement location="${mvc}.jar" /&gt
			&lt/classpath&gt
		&lt/javadoc&gt
		&ltexec executable="open"&gt
			&ltarg line="-a /Applications/Safari.app ${docdir}/index.html" /&gt
		&lt/exec&gt
		&ltexec executable="date" spawn="false" /&gt
	&lt/target&gt

	&lttarget name="zip" depends="clean" description="make zip file"&gt
		&ltdelete file="../${zipname}.zip" /&gt
		&ltzip destfile="../${zipname}.zip"&gt
			&ltzipfileset dir="." prefix="${zipname}" /&gt
		&lt/zip&gt
		&ltexec executable="date" spawn="false" /&gt
	&lt/target&gt

&lt/project&gt
</pre>
<div >
    <h3><a name="forest" href="https://github.com/Fujiya-San/Forest/blob/master/Forest_Program/forest.mf"><pre class = "belt-yellow">forest.mf</pre></a></h3>
</div>
<pre>
Manifest-Version: 1.0
Main-Class: forest.Example
</pre>
<div >
    <h3><a name="Makefile" href="https://github.com/Fujiya-San/Forest/blob/master/Forest_Program/Makefile"><pre class = "belt-yellow">Makefile</pre></a></h3>
</div>
<pre>
ANT	= env LC_ALL=ja_JP.UTF-8 ant

all:
	$(ANT) all

clean:
	$(ANT) clean

test:
	$(ANT) test

tree: clean
	$(ANT) tree

forest: clean
	$(ANT) forest

semilattice: clean
	$(ANT) semilattice

install:
	$(ANT) install

doc:
	$(ANT) doc

zip:
	$(ANT) zip
</pre>
<hr>
<div class="right-small">Copyright 20xx Project xx, Updated: 2019/07/29 (Created: 2019/07/29)</div>
</body>
</html>
